#### 树的基本概念和存储方法
树：具有n(n>=0)个结点的集合，其中：
- n=0 表示一颗空树
- n>0 ， 仅存在一个根节点，其余结点氛围若干集合构成根节点的**子树**，子树也是一棵树
![树的基本概念](http://ozgulqqe9.bkt.clouddn.com/0b033fab59b975394ffb8a24473afa8a.png)

##### 相关术语：
- 空树、树枝、树叶、儿子、父亲、兄弟、祖先、子孙
- 结点的度、树的元数、结点的层数、结点的高度、根到叶的路径、树高、有序树、位置树、K 正则树、森林

###### 结点的度-其子树的个数
![结点的度](http://ozgulqqe9.bkt.clouddn.com/e58b23700c2c88075046f7c8446decef.png)

###### 树的元数-结点度数的最大允许值m，m元正则树--非叶结点都有m个儿子
###### 叶子--度数为0的结点（也称终端结点），非叶结点又称为分枝点（或内结点）
![叶子](http://ozgulqqe9.bkt.clouddn.com/e00b4260d801f1607afe7173f4c90536.png)
###### 结点的层数：根的层数定为1；递推地，第i层结点的儿子层数为i+1
###### 结点的高度：叶子的高都定为1；递推地，非叶结点的高等于它各个儿子高度的最大值加1；树（包括子树）的高度等于其根的高度。
###### 有序树和无序树
![有序树和无序树](http://ozgulqqe9.bkt.clouddn.com/680bb3ec17ca041079cebfd79f8c7813.png)
###### 位置树
###### 森林==树的集合称为森林，一个森林可包含0至多个树

##### 树的表示
![树的表示](http://ozgulqqe9.bkt.clouddn.com/03be1266cbf54257436d770331e28062.png)

##### 树的存储方法
- 多重链接
- 儿子兄弟链
- 父亲链域

---

#### 二叉树
##### 二叉树的基本概念
![二叉树的基本概念](http://ozgulqqe9.bkt.clouddn.com/56449649fa4526c81adb55ec6e62cb15.png)

##### 二叉树的性质
- 非空二叉树中，第i 层（i≥1 ）上结点的 个数 为：n i ≤2 i-1
- 高度为k （k≥0 ）的二叉树中，结点 总数为 为m k ≤2 k -1
- n 个结点的二叉树的高 高h 满足：h≥[log 2 n]+1

##### 满二叉树：高为k ，结点数=2 k -1 的二叉树
![满二叉树](http://ozgulqqe9.bkt.clouddn.com/9c77b21bd279e85d6c2df9cb74ce6429.png)

##### 完全二叉树
在高为k 的满二叉树中，按层次顺序从左至右从编号1 开始，连续取n （0≤n≤2 k -1 ）个结点所构成的二叉树
![完全二叉树](http://ozgulqqe9.bkt.clouddn.com/8732d56b18b2ed4245342e5f973b724c.png)

##### 二叉树的存储
- 双链法（主要）： 找儿子易，找父亲难；
- 完全二叉树的顺序存储法：直接定位父与子

#### 森林、树、二叉树
- 森林、树、二叉树可以相互转换
- 二叉树是树结构的基础

#### 二叉树的遍历：按一定的规律 “ 访问 ” 二叉树中的每个结点，且只访问一次
![二叉树的遍历](http://ozgulqqe9.bkt.clouddn.com/8ec6421dc37a2df1d8f9718e40770736.png)

###### 先根遍历：先访问二叉树的根，然后访问二叉树的左子树，再访问二叉树的右子树。对二叉树左、右子树的访问也是“先根遍历
![二叉树先根遍历](http://ozgulqqe9.bkt.clouddn.com/511c114a48617493be9a787937f97f44.png)
###### 中根遍历：先访问二叉树的左子树，然后访问二叉树的根，再访问二叉树的右子树。对二叉树左、右子树的访问也是 “ 中根遍历
![二叉树中根遍历](http://ozgulqqe9.bkt.clouddn.com/e88dc073b5a28d983d79577fb399821a.png)
###### 后根遍历：先访问二叉树的左子树，然后访问二叉树的右子树，最后访问二叉树的根。对二叉树左、右子树的访问也是 “ 后根遍历
![二叉树后根遍历](http://ozgulqqe9.bkt.clouddn.com/5f7af713f1847cb15f33700f17e5e78a.png)

##### 二叉树遍历的作用
- 先序遍历可求二叉树各结点层数
- 后序遍历求二叉树各结点的高度
- 先序和后序相结合求给定结点的所有子孙
- 采用何种遍历取决于对二叉树进行的操作

#### 二叉树的构造
- 仅一个先（中、后）序序列不能构造唯一一棵二叉树
- 用先（后）序序列和中序序列可以构造唯一一棵二叉树
- 递归算法实现先（后）序序列和中序序列构造二叉树
- 用扩充先（后）序序列可以构造唯一一棵二叉树
- 用扩充中序序列不能构造唯一一棵二叉树

---

#### 检索树
也称排序树，二叉树中任何一个值为a的 的结点，其左子树上结点值均小于或等于a，其右子树上的结点值均大于

##### 检索树的查找: 基本思想
只需沿着根到某个叶结点的一条路径搜索，使x 与当前结点值比较：
- 遇到空树，结点x 不在树中，查找失败
- 如果相等，找到x ，查找成功
- 若x 小于当前结点值， 递归 地查找左子树
- 若x 大于当前结点值， 递归 地查找右子树
![检索树的查找](http://ozgulqqe9.bkt.clouddn.com/db94b9f737883e4c45a4b786889e3521.png)

##### 检索树的查找算法分析
- 查找成功，查找长度等于结点x 在树中的层数。
- 查找不成功，查找将终止于某个结点y ，这个结点y

  - 必然至少缺少一个儿子，那么查找长度等于y 的层数。
  - 检索树的查找算法分析：检索树查找长度不超过树的高度h--（logn≤h≤n）

##### 检索树的插入：
- 找到插入结点的有序位置进行插入
- 基本原则：简单、保中序
- 从根结点起 ， 将要插入的元素x 与当前的结点比较 ，如果x 小于或等于当前结点值 ，果 就向左搜索；如果x大于当前结点值 ， 就向右搜索；直至遇到空结点 ， 就将x 作为一片新叶插在这个空位置上。

##### 检索树的删除
先找到要删除的结点x， ， 并记下结点x 的父亲f
（1）若x 是叶 ，把 把f 指向x 的链域（ （Lson 或Rson） ） 置空，就删除了x
（2）若x 只有一个儿子 ，将 将f 指向x 的链域（Lson 或Rson）改为指向x 的儿子；
（3）若 若x 有两个儿子 ， 先找到x 的中序前趋y，用结点y 代替结点x，并删除结点y

##### 小结
- 左小右大，中序有序。
- 检索树的查找可采用递归和非递归算法实现。
- 检索树插入的新结点都是作为新的叶子。
- 检索树删除结点分叶结点、单枝结点和双枝结点分别处理。
- 检索树查找、插入、删除算法的时间复杂度取决于树高，
- 平均性能是O(logn) ，最坏情况O(n)。

---

#### 平衡树
##### 基本概念
- 二叉平衡检索树（简称平衡树）

  - 树的高度h 限制在结点数n 的对数阶范围内--h=O(logn)
- 平衡树是一类树的总称（又称为平衡树模式）

##### AVL 树：前苏联学者Adelson-Velskii 和Landis 的名字命名
- h ≤1.45logn
- 二叉树的右、左子树的高度差不超过1
- 二叉平衡树
- 平衡因子：右、左子树高度之差
- 二叉平衡检索树
  - 既是AVL 树，也是检索树。
  - 结点的平衡因子：0 、1 、-1

##### 平衡树相关操作
- 平衡树的查找、插入、构造、删除同检索树。
- 平衡树上查找、插入、删除一个结点所需时间不超过 O(1.45logn)
- 当插入、删除破坏平衡条件时，要调整树结构，使它保持平衡（同时保中序）

##### 平衡树的插入
- 像一般的 检索树 那样 插入x（ （ 新叶 ）； ；
- 沿插入x 的路径 返回 ， 修改x 祖先的平衡因子；
- 回溯 中 ， 一旦发现x 的祖先p 失衡
  - 由p->bal=1变成p->bal=2
  - 由p->bal=-1变成p->bal=-2
  - 旋转以p 为根的子树 ， 使之平衡

##### 旋转：LL ，LR ，RR ，RL
- 左 左 子树增高：即 p->bal  由 -1 → -2 ，LL 、LR 旋转。
- 右 右 子树增高：即 p->bal  由1 → 2 ，RR ，RL 旋转。

##### 平衡树的删除
- 同检索树的删除；
- 若删除，破坏了树的平衡，旋转；
- 旋转后子树高度还降低，继续回溯；
- 一次删除，可能引起多次旋转

##### 小结
- 平衡树的定义、性质
  - 平衡因子（AVL 树）
- 平衡树的插入和构造
  - 三层之内旋转（单旋、双旋）
- 平衡树的删除法
  - 可能旋转多次

---

#### 哈夫曼树
###### 叶的路径长度：从根结点到叶结点的路径上的边数
###### 叶的加权路径长度：设二叉树的叶子，其权值为正实数w，路径长度为l ，那么，W*l称为该叶的加权路径长度
###### 二叉树的权:设二叉树T 具有n 片叶子，n 个正实数w1至wn作为各叶的权，根到第i（1≤i≤n）片叶子的路径长度（边数）为li，那么二叉树T的权为所有叶的加权路径长度之和。即：
![二叉树的权](http://ozgulqqe9.bkt.clouddn.com/d6d5568bc375a5c49f816ec504eb355b.png)

###### 哈夫曼树：给定n 个正实数w 1 至 至w n ，分别为n 片叶子的权，l 1 至 至l n 为对应叶子的路径长度，使权达最小值的树，称为哈夫曼树
![哈夫曼树的权](http://ozgulqqe9.bkt.clouddn.com/2d3a63c12b89d1b74dfc8f26ae326335.png)

###### 哈夫曼树必是正则二叉树
###### 一叶一树，最小合并

##### 哈夫曼树的构造
1、先构造n 棵单叶的二叉树（ （n 棵树组成森林 ） ， 依次将权w 1 ，w 2 ， ，…w n 赋给各个叶子；
2、反复合并（ （n-1遍 遍 ） ， 直到森林中只有一棵树：
  - 找出根的权最小的两棵树：T1 和T2 ；
  - 将T1 ，T2 合并成一棵树T， ，使 使T1 ，T2 分别作为T 的左右子树 ， 且使T 之根的权等于T1 ，T2 之根的权之和；
  - 把合并树T 加入森林中；

##### 哈夫曼编码
字符作为叶子，字符的使用频度，作为权值构成的哈夫曼树，若左分枝以“0” ，右分枝以“1” ，则从根到叶子的路径分枝上的01 字符串构成该叶子结点对应字符的编码。这种方法得到的字符编码称为 哈夫曼编码

**保证能唯一译码，且编码方案最佳**

##### 小结
- 哈夫曼编码是以哈夫曼树为编码树
- 哈夫曼编码是最短编码
- 哈夫曼编码译码唯一
- 通过哈夫曼编码可进行编码压缩











---
