##### 栈
1. 能够准确描述 **栈的特点**
2. 能够写出顺序栈的 **入栈** 和 **出栈** 算法
3. 能够写出链栈的 **入栈** 和 **出栈** 算法

###### 栈的基本概念
只允许在同一个端点处进行插入或删除的表结构称为 **栈** （stack）<br>
![栈的基本概念](http://ozgulqqe9.bkt.clouddn.com/d0d22048d3a11cafa8de193aa962dfd8.png)
- 栈顶（top）
- 栈底（bottom）
- 进栈（push）
- 出栈（pop）

###### 栈的特点
栈结构，像开口向上的圆桶，结点像编了号的木块
1. 先放的在下边，后放的在上边
2. 插入和删除操作只在一端(栈顶，Top)做插入、删除
3. 插入数据：**入栈（Push）**
4. 删除数据：**出栈（PoP）**
5. Last In First Out（**LIFO**）LIFO表/后进先出表
6. 堆栈的其他应用：函数调用及递归实现、深度优先搜索、回朔算法

##### 小结
- 栈是最常用的 表 结构
- 从根本上认识栈的基本原理和操作方法，对 于认识程序的
嵌套和递归调用，在 程序设计中自觉地使用栈具有 重要的
意义
- 在 应用方面，借助中缀表达式求值算法的原理，进一步理
解栈在算法设计中的应用 ，是非常必要的。

---

##### 队列
具有一定操作约束的线性表
![队列的基本概念](http://ozgulqqe9.bkt.clouddn.com/710e350dd3940c28e59e7988263c0a62.png)
- 插入端-->队尾（rear）
- 删除端-->对头（front）
- first last：分别指向对头元素和队尾元素
- 出队/进队


###### 队列的特点
1. 一端进入，另一端退出
2. 数据插入：**入队列（AddQ）**
3. 数据删除：**出队列（DeleteQ）**
4. 先来先服务：**先进先出**
5. First In First Out（**FIFO**）FIFO 表/先进先出表

###### 顺序队
1.  last 指向当前尾， ，first 指向当前头 （ 麻烦） ）
2. 尾指针last 前置
3. 首指针first 后置
4. 如何判断队空
    - 当first=last=i（i是0~m-1之间的任一值），都表示队空。
5. 如何判断队满
    - 在程序执行期间 ， 如果要求进队的元素总量不超过数组长度m， ， 不会出现队满情况
    - 在程序执行期间 ， 需要进队处理的元素总量多于m个 个，但任何时刻 ， 队中的元素数目始终小于m，仍可使用长度为m 的数组存储 （ 不会发生队满）

###### 循环队
重复使用已退队元素所占存储单元
- 判断队满队空的方法：少用一个单元
- 因此通用的计算队列长度公式为:
  > ( last- first + m) %m m 为表长

  > 队空 状态：first=last

  > 队满 状态：(last+1)%m==first

###### 链式队列
通常采用循环队列形式
- 链式队可采用 **单向加头链表** 结构，first 为首指针，last 为尾指针

- 进队：
将新结点插在表尾处，last 移向新结点

- 出队：
将头结点后的第一个元素出队 ， 删除头结点(**头结点不固定**) 保证尾结点不被删除first 和last同时指向头结点作为队空的判断条件



###### 中缀表达式如何让转换为后缀表达式：
  - 从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理
    1. 运算符：直接输出；
    2. 左括号：压入栈顶；
    3. 右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）
    4. 运算符：
      - 若优先级大于栈顶运算符时，则把它压栈；
      - 若优先级咸鱼等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；
    5.若各对象处理完毕，则把堆栈中存留的运算符一并输出

---

##### 散列表

###### 查找的实质
- 完成元素值k到存储地址d的变换f，即 d=f(k)
- 查找算法提现了数据的逻辑特性、物理存储和操作的一致性

###### 散列表和散列函数
- 散列函数也叫hash函数，杂凑函数
- 得到的散列存储空间：称作 **散列表**

###### 散列表中的冲突
- 如果 x!=y，而hash(x)=hash(y)，则称x与y发生冲突
- 理想情况：若任何x!=y，都有hash(x)!=hash(y)，所设计的散列函数很均匀。查找x时，就能在a[hsh(x)]中找到元素x

###### 散列函数的设计原则
无固定模式，只是随意拼凑
- 根据元素取值范围和分布规律采用拼凑方式，将元素x(的值)“打乱，弄碎”
- 从中提取一部分信息作为x的散列值
- 要尽可能均匀，不发生（或少发生）冲突

###### 散列函数的设计方法
- 取余法：
hash(x)=x 　mod 　p
- 提取数位法：
从元素x 中取出若干位拼成整数作为x 的散列值
- 平方取中法

- 折叠法

- 变换基数法

###### 散列表的处理算法
- 构造：从空表开始，逐一插入
- 插入：通过计算元素x的散列函数值和解决冲突方法为x找到一个空单元存储x
- 查找：通过计算元素x的散列函数值和解决冲突方法沿着x的插入路径就能找到x

1. 散列表的插入算法
> 步骤1 ）计算散列函数值h=hash(x) ；<br>
> 步骤2 ）if(a[h]==0)<br>
> {a[h]=x; return  插入成功信息；}<br>
> 步骤3 ）if(a[h]==x) return 出错信息; //x 已在表中<br>
> 步骤4 ）按预定的解决冲突方法，将x 插在表中

2. 散列表的查找算法
> 步骤1 ）计算散列函数值h=hash(x);<br>
> 步骤2 ）if(a[h]==x)return h; // 查找成功<br>
> 步骤3 ）if(a[h]==0)return 返回查找失败信息;<br>
> 步骤4 ）按插入时采用的冲突处理方法进行查找<br>

###### 散列表处理冲突的基本思路

- 把冲突的元素用链表连起来，称为链接法
- 当发生冲突时，反复用探测的方法在散列表中寻找下一个结点，称为开放地址法

  -这种探测的方法一定要满足某种规律，而且对插入和查找时一致的
  - 开放地址法的散列地址公式
![开放地址法的散列地址公式](http://ozgulqqe9.bkt.clouddn.com/a36fea7899481ca2ddd09eece1555fc1.png)
- 增量序列：增量序列是冲突次数i的线性函数
  - 线性序列----线性探测
  1. 优点：简单，可环视一周寻找空单元
  2. 缺点：易产生聚集现象，增加“冲突链”长度
  3. 二次散列小烈不佳，因为增量的：步长为1,改进措施：加大步长
  - 平方序列----平方探测
  1. 特点：变步长减少了聚集现象
  2. 确点：不易对表环视一周
  3. 原因：步长变化太大
  4. 改进措施：将步长改为正反平方数，从冲突起点（h0）向左右两边探测，减少探测死角
  - 随机序列----随机探测：散列效果很大程度上取决于伪随机函数的性能
![伪随机函数的最简单设计方法](http://ozgulqqe9.bkt.clouddn.com/2a60e77e4131ea43caf074bd87cf261c.png)

###### 散列表的删除算法（与解决冲突的方式有关）
- 使用链接法解决冲突时，删除算法与一般链表删除相似。
- 用开放地址法解决冲突时，删除算法较难。
  - 不能简单地置删除节点为空，这样会切断探测 “ 链 ” 。
  - 可以置删除节点为 “ 已删除标记 ” ，查找时跳过这些节点，在插入时，这些节点可以重新使用。
  - 定期对整个表重新散列.
